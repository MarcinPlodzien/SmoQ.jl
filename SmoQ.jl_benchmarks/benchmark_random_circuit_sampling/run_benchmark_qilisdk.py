#!/usr/bin/env python3
"""
run_benchmark_qilisdk.py - QiliSDK random circuit sampling benchmark

Loads shared circuits from circuits/ (generated by generate_circuits.py)
so all frameworks benchmark the EXACT SAME circuit.

Usage: python run_benchmark_qilisdk.py
Requirements: pip install qilisdk qutip qutip-qip
"""

import os
import time
import numpy as np
from datetime import datetime

# Configuration
N_SHOTS = 100
N_RANGE_QUTIP = range(2, 12, 2)   # QuTiP is very slow, limit to N=10
N_RANGE_QILISIM = range(2, 21, 2)  # QiliSim can go to 20
N_WARMUP = 1

SCRIPT_DIR = os.path.dirname(os.path.abspath(__file__))
CIRCUIT_DIR = os.path.join(SCRIPT_DIR, "circuits")

try:
    from qilisdk.digital import Circuit, H, X, Y, Z, S, T, RX, RY, RZ, CNOT, CZ, M
    from qilisdk.backends.qilisim import QiliSim
    from qilisdk.backends.qutip_backend import QutipBackend
    from qilisdk.functionals import Sampling
except ImportError as e:
    print(f"Import error: {e}")
    print("Please install: pip install qilisdk qutip qutip-qip")
    exit(1)


def load_circuit_qilisdk(n_qubits: int):
    """Load a shared circuit file and build a QiliSDK Circuit."""
    filepath = os.path.join(CIRCUIT_DIR, f"circuit_N{n_qubits:02d}.txt")
    circuit = Circuit(n_qubits)

    with open(filepath) as f:
        for line in f:
            line = line.strip()
            if not line or line.startswith("#"):
                continue
            parts = line.split()
            gate = parts[0]
            if gate == "H":
                circuit.add(H(int(parts[1])))
            elif gate == "X":
                circuit.add(X(int(parts[1])))
            elif gate == "Y":
                circuit.add(Y(int(parts[1])))
            elif gate == "Z":
                circuit.add(Z(int(parts[1])))
            elif gate == "S":
                circuit.add(S(int(parts[1])))
            elif gate == "T":
                circuit.add(T(int(parts[1])))
            elif gate == "RX":
                circuit.add(RX(int(parts[1]), theta=float(parts[2])))
            elif gate == "RY":
                circuit.add(RY(int(parts[1]), theta=float(parts[2])))
            elif gate == "RZ":
                circuit.add(RZ(int(parts[1]), phi=float(parts[2])))
            elif gate == "CNOT":
                circuit.add(CNOT(int(parts[1]), int(parts[2])))
            elif gate == "CZ":
                circuit.add(CZ(int(parts[1]), int(parts[2])))

    # Add measurement on all qubits
    for q in range(n_qubits):
        circuit.add(M(q))

    return circuit


def run_benchmark_backend(backend, backend_name: str, n_range, output_file: str):
    """Run benchmark for a specific backend, saving incrementally."""
    print(f"\n  Backend: {backend_name}")
    print("     N  │    Time (s)")
    print("  ──────┼──────────────")

    timings = {}

    for n in n_range:
        try:
            circuit = load_circuit_qilisdk(n)

            # Warmup
            for _ in range(N_WARMUP):
                backend.execute(Sampling(circuit, N_SHOTS))

            # Benchmark
            start = time.perf_counter()
            backend.execute(Sampling(circuit, N_SHOTS))
            elapsed = time.perf_counter() - start

            timings[n] = elapsed
            print(f"    {n:2d}  │  {elapsed:10.4f}", flush=True)
        except Exception as e:
            print(f"    {n:2d}  │  ERROR: {e}", flush=True)
            continue

        # Save after EVERY N value so kills don't lose data
        output_path = os.path.join(SCRIPT_DIR, output_file)
        with open(output_path, "w") as f:
            f.write(f"# QiliSDK:{backend_name} benchmark - {datetime.now()}\n")
            f.write("# N\tTime_s\n")
            for nn, tt in sorted(timings.items()):
                f.write(f"{nn}\t{tt:.6f}\n")

    print(f"\n  Saved: {output_file}")
    return timings


def run_benchmark():
    print("=" * 70)
    print("  QiliSDK — Random Circuit Sampling Benchmark")
    print("=" * 70)
    print(f"\n  Shots: {N_SHOTS}")
    print(f"  Circuits: shared (seed=42, from circuits/)")

    # QiliSim backend (faster, run first)
    print(f"\n  QiliSim range: {min(N_RANGE_QILISIM)}-{max(N_RANGE_QILISIM)}")
    qilisim = QiliSim()
    run_benchmark_backend(qilisim, 'QiliSim', N_RANGE_QILISIM, "timings_qilisdk_qilisim.txt")

    # QuTiP backend (slow, limited range)
    print(f"\n  QuTiP range: {min(N_RANGE_QUTIP)}-{max(N_RANGE_QUTIP)}")
    qutip = QutipBackend()
    run_benchmark_backend(qutip, 'QuTiP', N_RANGE_QUTIP, "timings_qilisdk_qutip.txt")


if __name__ == "__main__":
    run_benchmark()
