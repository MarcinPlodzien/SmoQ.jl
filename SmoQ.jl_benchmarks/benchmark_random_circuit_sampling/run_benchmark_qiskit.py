#!/usr/bin/env python3
"""
run_benchmark_qiskit.py - Qiskit Aer random circuit sampling benchmark

Loads shared circuits from circuits/ (generated by generate_circuits.py)
so all frameworks benchmark the EXACT SAME circuit.

Usage: python run_benchmark_qiskit.py
Requirements: pip install qiskit qiskit-aer
"""

import os
import time
import numpy as np
from datetime import datetime

# Configuration
N_SHOTS = 100
N_RANGE = range(2, 21, 2)
N_WARMUP = 3

SCRIPT_DIR = os.path.dirname(os.path.abspath(__file__))
CIRCUIT_DIR = os.path.join(SCRIPT_DIR, "circuits")

try:
    from qiskit import QuantumCircuit
    from qiskit_aer import AerSimulator
except ImportError:
    print("Please install Qiskit: pip install qiskit qiskit-aer")
    exit(1)


def load_circuit_qiskit(n_qubits: int) -> QuantumCircuit:
    """Load a shared circuit file and build a Qiskit QuantumCircuit."""
    filepath = os.path.join(CIRCUIT_DIR, f"circuit_N{n_qubits:02d}.txt")
    qc = QuantumCircuit(n_qubits, n_qubits)

    with open(filepath) as f:
        for line in f:
            line = line.strip()
            if not line or line.startswith("#"):
                continue
            parts = line.split()
            gate = parts[0]
            if gate == "H":
                qc.h(int(parts[1]))
            elif gate == "X":
                qc.x(int(parts[1]))
            elif gate == "Y":
                qc.y(int(parts[1]))
            elif gate == "Z":
                qc.z(int(parts[1]))
            elif gate == "S":
                qc.s(int(parts[1]))
            elif gate == "T":
                qc.t(int(parts[1]))
            elif gate == "RX":
                qc.rx(float(parts[2]), int(parts[1]))
            elif gate == "RY":
                qc.ry(float(parts[2]), int(parts[1]))
            elif gate == "RZ":
                qc.rz(float(parts[2]), int(parts[1]))
            elif gate == "CNOT":
                qc.cx(int(parts[1]), int(parts[2]))
            elif gate == "CZ":
                qc.cz(int(parts[1]), int(parts[2]))

    qc.measure(range(n_qubits), range(n_qubits))
    return qc


def run_benchmark():
    print("=" * 70)
    print("  Qiskit Aer — Random Circuit Sampling Benchmark")
    print("=" * 70)
    print(f"\n  Shots: {N_SHOTS}")
    print(f"  Qubit range: {min(N_RANGE)}-{max(N_RANGE)}")
    print(f"  Circuits: shared (seed=42, from circuits/)")

    simulator = AerSimulator()
    timings = {}

    print("\n     N  │    Time (s)")
    print("  ──────┼──────────────")

    for n in N_RANGE:
        qc = load_circuit_qiskit(n)

        # Warmup
        for _ in range(N_WARMUP):
            simulator.run(qc, shots=N_SHOTS).result()

        # Benchmark
        start = time.perf_counter()
        simulator.run(qc, shots=N_SHOTS).result()
        elapsed = time.perf_counter() - start

        timings[n] = elapsed
        print(f"    {n:2d}  │  {elapsed:10.4f}")

    # Save results
    output_file = os.path.join(SCRIPT_DIR, "timings_qiskit_aer.txt")
    with open(output_file, "w") as f:
        f.write(f"# Qiskit Aer benchmark - {datetime.now()}\n")
        f.write("# N\tTime_s\n")
        for n in N_RANGE:
            f.write(f"{n}\t{timings[n]:.6f}\n")
    print(f"\nSaved: timings_qiskit_aer.txt")


if __name__ == "__main__":
    run_benchmark()
