#!/usr/bin/env python3
"""
run_benchmark_pennylane.py - PennyLane Lightning random circuit sampling benchmark

Loads shared circuits from circuits/ (generated by generate_circuits.py)
so all frameworks benchmark the EXACT SAME circuit.

Usage: python run_benchmark_pennylane.py
Requirements: pip install pennylane pennylane-lightning
"""

import os
import time
import numpy as np
from datetime import datetime

# Configuration
N_SHOTS = 100
N_RANGE = range(2, 21, 2)
N_WARMUP = 3

SCRIPT_DIR = os.path.dirname(os.path.abspath(__file__))
CIRCUIT_DIR = os.path.join(SCRIPT_DIR, "circuits")

try:
    import pennylane as qml
except ImportError:
    print("Please install PennyLane: pip install pennylane pennylane-lightning")
    exit(1)


def load_gate_sequence(n_qubits: int):
    """Load gate sequence from shared circuit file."""
    filepath = os.path.join(CIRCUIT_DIR, f"circuit_N{n_qubits:02d}.txt")
    gate_sequence = []

    with open(filepath) as f:
        for line in f:
            line = line.strip()
            if not line or line.startswith("#"):
                continue
            parts = line.split()
            gate = parts[0]
            q1 = int(parts[1])

            if gate in ("H", "X", "Y", "Z", "S", "T"):
                gate_sequence.append((gate, q1, None, None))
            elif gate in ("RX", "RY", "RZ"):
                gate_sequence.append((gate, q1, None, float(parts[2])))
            elif gate in ("CNOT", "CZ"):
                gate_sequence.append((gate, q1, int(parts[2]), None))

    return gate_sequence


def run_circuit(n_qubits: int, gate_sequence, n_shots: int):
    """Run the pre-loaded circuit with PennyLane."""
    try:
        dev = qml.device("lightning.qubit", wires=n_qubits, shots=n_shots)
    except:
        dev = qml.device("default.qubit", wires=n_qubits, shots=n_shots)

    @qml.qnode(dev)
    def circuit():
        for gate, q1, q2, theta in gate_sequence:
            if gate == "H":
                qml.Hadamard(wires=q1)
            elif gate == "X":
                qml.PauliX(wires=q1)
            elif gate == "Y":
                qml.PauliY(wires=q1)
            elif gate == "Z":
                qml.PauliZ(wires=q1)
            elif gate == "S":
                qml.S(wires=q1)
            elif gate == "T":
                qml.T(wires=q1)
            elif gate == "RX":
                qml.RX(theta, wires=q1)
            elif gate == "RY":
                qml.RY(theta, wires=q1)
            elif gate == "RZ":
                qml.RZ(theta, wires=q1)
            elif gate == "CNOT":
                qml.CNOT(wires=[q1, q2])
            elif gate == "CZ":
                qml.CZ(wires=[q1, q2])
        return qml.sample(wires=range(n_qubits))

    return circuit()


def run_benchmark():
    print("=" * 70)
    print("  PennyLane Lightning — Random Circuit Sampling Benchmark")
    print("=" * 70)
    print(f"\n  Shots: {N_SHOTS}")
    print(f"  Qubit range: {min(N_RANGE)}-{max(N_RANGE)}")
    print(f"  Circuits: shared (seed=42, from circuits/)")

    timings = {}

    print("\n     N  │    Time (s)")
    print("  ──────┼──────────────")

    for n in N_RANGE:
        gate_sequence = load_gate_sequence(n)

        # Warmup
        for _ in range(N_WARMUP):
            run_circuit(n, gate_sequence, N_SHOTS)

        # Benchmark — only simulation + sampling, not circuit construction
        start = time.perf_counter()
        run_circuit(n, gate_sequence, N_SHOTS)
        elapsed = time.perf_counter() - start

        timings[n] = elapsed
        print(f"    {n:2d}  │  {elapsed:10.4f}")

    # Save results
    output_file = os.path.join(SCRIPT_DIR, "timings_pennylane.txt")
    with open(output_file, "w") as f:
        f.write(f"# PennyLane Lightning benchmark - {datetime.now()}\n")
        f.write("# N\tTime_s\n")
        for n in N_RANGE:
            f.write(f"{n}\t{timings[n]:.6f}\n")
    print(f"\nSaved: timings_pennylane.txt")


if __name__ == "__main__":
    run_benchmark()
