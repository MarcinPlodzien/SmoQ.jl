#!/usr/bin/env python3
"""
run_benchmark_cirq.py - Cirq random circuit sampling benchmark

Loads shared circuits from circuits/ (generated by generate_circuits.py)
so all frameworks benchmark the EXACT SAME circuit.

Usage: python run_benchmark_cirq.py
Requirements: pip install cirq
"""

import os
import time
import numpy as np
from datetime import datetime

# Configuration
N_SHOTS = 100
N_RANGE = range(2, 21, 2)
N_WARMUP = 3

SCRIPT_DIR = os.path.dirname(os.path.abspath(__file__))
CIRCUIT_DIR = os.path.join(SCRIPT_DIR, "circuits")

try:
    import cirq
except ImportError:
    print("Please install Cirq: pip install cirq")
    exit(1)


def load_circuit_cirq(n_qubits: int) -> cirq.Circuit:
    """Load a shared circuit file and build a Cirq Circuit."""
    filepath = os.path.join(CIRCUIT_DIR, f"circuit_N{n_qubits:02d}.txt")
    qubits = cirq.LineQubit.range(n_qubits)
    circuit = cirq.Circuit()

    with open(filepath) as f:
        for line in f:
            line = line.strip()
            if not line or line.startswith("#"):
                continue
            parts = line.split()
            gate = parts[0]
            if gate == "H":
                circuit.append(cirq.H(qubits[int(parts[1])]))
            elif gate == "X":
                circuit.append(cirq.X(qubits[int(parts[1])]))
            elif gate == "Y":
                circuit.append(cirq.Y(qubits[int(parts[1])]))
            elif gate == "Z":
                circuit.append(cirq.Z(qubits[int(parts[1])]))
            elif gate == "S":
                circuit.append(cirq.S(qubits[int(parts[1])]))
            elif gate == "T":
                circuit.append(cirq.T(qubits[int(parts[1])]))
            elif gate == "RX":
                circuit.append(cirq.rx(float(parts[2]))(qubits[int(parts[1])]))
            elif gate == "RY":
                circuit.append(cirq.ry(float(parts[2]))(qubits[int(parts[1])]))
            elif gate == "RZ":
                circuit.append(cirq.rz(float(parts[2]))(qubits[int(parts[1])]))
            elif gate == "CNOT":
                circuit.append(cirq.CNOT(qubits[int(parts[1])], qubits[int(parts[2])]))
            elif gate == "CZ":
                circuit.append(cirq.CZ(qubits[int(parts[1])], qubits[int(parts[2])]))

    circuit.append(cirq.measure(*qubits, key='result'))
    return circuit


def run_benchmark():
    print("=" * 70)
    print("  Cirq — Random Circuit Sampling Benchmark")
    print("=" * 70)
    print(f"\n  Shots: {N_SHOTS}")
    print(f"  Qubit range: {min(N_RANGE)}-{max(N_RANGE)}")
    print(f"  Circuits: shared (seed=42, from circuits/)")

    simulator = cirq.Simulator()
    timings = {}

    print("\n     N  │    Time (s)")
    print("  ──────┼──────────────")

    for n in N_RANGE:
        circuit = load_circuit_cirq(n)

        # Warmup
        for _ in range(N_WARMUP):
            simulator.run(circuit, repetitions=N_SHOTS)

        # Benchmark
        start = time.perf_counter()
        simulator.run(circuit, repetitions=N_SHOTS)
        elapsed = time.perf_counter() - start

        timings[n] = elapsed
        print(f"    {n:2d}  │  {elapsed:10.4f}")

    # Save results
    output_file = os.path.join(SCRIPT_DIR, "timings_cirq.txt")
    with open(output_file, "w") as f:
        f.write(f"# Cirq benchmark - {datetime.now()}\n")
        f.write("# N\tTime_s\n")
        for n in N_RANGE:
            f.write(f"{n}\t{timings[n]:.6f}\n")
    print(f"\nSaved: timings_cirq.txt")


if __name__ == "__main__":
    run_benchmark()
