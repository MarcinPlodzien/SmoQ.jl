#!/usr/bin/env julia
#=
################################################################################
#           OAT + HAAR RANDOM: QUANTUM RESOURCE COMPARISON
################################################################################
#
# PURPOSE
# =======
# Compare quantum resources (Bell correlations, magic, metrological sensitivity)
# for states generated by:
#   1. OAT (One-Axis Twisting) evolution: structured entanglement
#   2. OAT + Haar random unitary: scrambled/randomized entanglement
#
# WORKFLOW
# ========
# 1. Evolve |+⟩^⊗N under H_OAT = χ Σᵢ<ⱼ ZᵢZⱼ for total time π/2
# 2. Store N_snapshots statevectors at regular intervals
# 3. For each |ψ(t)⟩, compute:
#    a) Many-body Bell correlator Q_ent, Q_bell (nonlocality)
#    b) SRE M₂(ψ) using fast Walsh-Hadamard (magic/non-stabilizerness)
#    c) Quantum Fisher Information F_max (metrological sensitivity)
# 4. Apply N_Haar random unitaries to each |ψ(t)⟩ and average metrics
# 5. Generate comparison plot: left=OAT, right=OAT+Haar
#
# PHYSICS INSIGHT
# ===============
# - OAT generates structured entanglement useful for sensing (spin squeezing)
# - Haar random scrambles correlations but preserves total entanglement entropy
# - We expect: OAT has higher QFI (metrological), Haar has higher magic (SRE)
#
# OUTPUT
# ======
# - data/data_OAT_N{N}.txt: OAT results vs time
# - data/data_Haar_N{N}.txt: Haar-averaged results
# - figures/fig_OAT_vs_Haar_N{N}.png: comparison plot
#
# REFERENCES
# ==========
# [1] Kitagawa & Ueda, PRA 47, 5138 (1993) - Spin squeezing
# [2] Leone et al., PRL 128, 050402 (2022) - Stabilizer Rényi entropy
# [3] Płodzień et al., PRL 129, 250402 (2022) - Many-body Bell correlations
#
################################################################################
=#

using LinearAlgebra
using Printf
using Plots; gr()
using Statistics
using ProgressMeter
using LaTeXStrings
using Optim  # For L-BFGS fallback

# ==============================================================================
# SETUP - Include matrix-free bitwise codebase modules
# ==============================================================================
SCRIPT_DIR = @__DIR__
UTILS_CPU = joinpath(SCRIPT_DIR, "../utils/cpu")
OUTPUT_DIR = joinpath(SCRIPT_DIR, "demo_OAT_plus_Haar")
DATA_DIR = joinpath(OUTPUT_DIR, "data")
FIG_DIR = joinpath(OUTPUT_DIR, "figures")
mkpath(DATA_DIR)
mkpath(FIG_DIR)

# Core modules - order matters!
include(joinpath(UTILS_CPU, "cpuQuantumStatePartialTrace.jl"))
include(joinpath(UTILS_CPU, "cpuQuantumStatePreparation.jl"))
include(joinpath(UTILS_CPU, "cpuQuantumChannelGates.jl"))
include(joinpath(UTILS_CPU, "cpuQuantumStateObservables.jl"))
include(joinpath(UTILS_CPU, "cpuQuantumChannelUnitaryEvolutionTrotter.jl"))
include(joinpath(UTILS_CPU, "cpuQuantumChannelRandomUnitaries.jl"))

# Bell correlator module
include(joinpath(UTILS_CPU, "cpuQuantumStateManyBodyBellCorrelator.jl"))

# Fast SRE module
include(joinpath(UTILS_CPU, "cpuStabilizerRenyiEntropyFastWalshHadamardTransform.jl"))

# QFI module
include(joinpath(UTILS_CPU, "cpuQuantumFisherInformation.jl"))

using .CPUQuantumStatePartialTrace
using .CPUQuantumStatePreparation: make_ket, normalize_state!
using .CPUQuantumChannelUnitaryEvolutionTrotter: FastTrotterGate, apply_fast_trotter_step_cpu!
using .CPUQuantumChannelRandomUnitaries: random_unitary
using .CPUQuantumStateManyBodyBellCorrelator: get_bell_correlator
using .CPUStabilizerRenyiEntropyFastWalshHadamardTransform: get_stabilizer_renyi_entropy
using .CPUQuantumFisherInformation: get_qfi

# ==============================================================================
# CONFIGURATION
# ==============================================================================
const N_range = [4, 6, 8]           # System sizes
const χ = 1.0                          # OAT coupling strength
const T_max = π / 2                    # Total evolution time
const dt = 0.01                        # Trotter step
const N_snapshots = 100                 # Number of time snapshots
const N_Haar = 100                      # Number of Haar unitaries to average

# Bell optimization - compare different optimizers
const OPTIMIZERS = [:spsa_adam, :lbfgs, :autograd_adam]
const OPT_ITER = 500                   # Optimization iterations
const OPT_METHOD = :lbfgs              # Default optimizer (will compare all)

# ==============================================================================
# OAT TROTTER GATES (zero Trotter error - all ZZ commute)
# ==============================================================================
const σz = ComplexF64[1 0; 0 -1]

function build_oat_gates(N::Int, χ::Float64, dt::Float64)
    H_zz = χ * kron(σz, σz)
    U_zz = exp(-1im * dt * H_zz)

    gates = FastTrotterGate[]
    for i in 1:N
        for j in (i+1):N
            push!(gates, FastTrotterGate([i, j], U_zz))
        end
    end
    return gates
end

# ==============================================================================
# COMPUTE QFI - Using module's finite-difference SLD implementation
# ==============================================================================
using .CPUQuantumFisherInformation: get_qfi_finite_diff

"""
Compute maximum QFI over all generator directions using SLD with finite differences.
For OAT: initial CSS along x, so Jx gives F~0, Jy/Jz give F ≥ N (SQL).
"""
function compute_qfi_max(ψ::Vector{ComplexF64}, N::Int)
    all_qubits = collect(1:N)

    F_x = get_qfi_finite_diff(ψ, N, all_qubits, :x)
    F_y = get_qfi_finite_diff(ψ, N, all_qubits, :y)
    F_z = get_qfi_finite_diff(ψ, N, all_qubits, :z)

    return max(F_x, F_y, F_z)
end

# ==============================================================================
# COMPUTE METRICS FOR PURE STATES
# ==============================================================================
function compute_metrics(ψ::Vector{ComplexF64}, N::Int)
    # 1. Many-body Bell correlator (optimizes measurement bases)
    Q_bell, Q_ent, _ = get_bell_correlator(ψ; method=OPT_METHOD, max_iter=OPT_ITER)

    # 2. Stabilizer Rényi entropy (measures magic/non-stabilizerness)
    SRE = get_stabilizer_renyi_entropy(ψ)

    # 3. QFI via SLD with θ encoding (max over all directions)
    F_Q = compute_qfi_max(ψ, N)

    return Q_bell, Q_ent, SRE, F_Q
end

# ==============================================================================
# OPTIMIZER COMPARISON - Find best optimizer for Bell correlator
# ==============================================================================
function compare_optimizers(N::Int, n_test_states::Int=5)
    println("\n" * "="^70)
    println("  OPTIMIZER COMPARISON (N=$N)")
    println("="^70)

    # Generate test states at different OAT evolution times
    gates = build_oat_gates(N, χ, dt)
    ψ = make_ket("|+>", N)

    N_steps = floor(Int, T_max / dt)
    test_times = [π/8, π/4, 3π/8]  # Sample times
    test_states = Vector{ComplexF64}[]

    ψ_copy = copy(ψ)
    current_step = 0
    for t_target in test_times
        target_step = floor(Int, t_target / dt)
        for step in (current_step+1):target_step
            apply_fast_trotter_step_cpu!(ψ_copy, gates, N)
            normalize_state!(ψ_copy)
        end
        push!(test_states, copy(ψ_copy))
        current_step = target_step
    end

    # Test each optimizer
    results = Dict{Symbol, Vector{Tuple{Float64, Float64, Float64}}}()

    for opt in OPTIMIZERS
        println("\n  Testing :$opt...")
        results[opt] = Tuple{Float64, Float64, Float64}[]

        for (i, (ψ_test, t)) in enumerate(zip(test_states, test_times))
            t_start = time()
            Q_bell, Q_ent, _ = get_bell_correlator(ψ_test; method=opt, max_iter=OPT_ITER)
            elapsed = time() - t_start
            push!(results[opt], (Q_bell, Q_ent, elapsed))
            @printf("    t=%.3f: Q_bell=%+.3f, Q_ent=%+.3f, time=%.2fs\n",
                    t, Q_bell, Q_ent, elapsed)
        end
    end

    # Save comparison to file
    comp_file = joinpath(DATA_DIR, "optimizer_comparison_N$N.txt")
    open(comp_file, "w") do f
        println(f, "# Optimizer comparison for Bell correlator (N=$N)")
        println(f, "# Format: optimizer  t  Q_bell  Q_ent  time_s")
        for opt in OPTIMIZERS
            for (i, t) in enumerate(test_times)
                Q_bell, Q_ent, elapsed = results[opt][i]
                @printf(f, "%s  %.4f  %+.6f  %+.6f  %.4f\n",
                        opt, t, Q_bell, Q_ent, elapsed)
            end
        end
    end
    println("\n  Saved: data/optimizer_comparison_N$N.txt")

    # Find best optimizer (highest average Q_bell)
    avg_qbell = Dict(opt => mean([r[1] for r in results[opt]]) for opt in OPTIMIZERS)
    best_opt = argmax(avg_qbell)
    println("\n  Best optimizer: :$best_opt (avg Q_bell = $(round(avg_qbell[best_opt], digits=3)))")

    return best_opt
end

# ==============================================================================
# MAIN SIMULATION FOR ONE N
# ==============================================================================
function run_simulation(N::Int)
    println("\n" * "="^70)
    println("  OAT + HAAR: N = $N qubits")
    println("="^70)

    N_steps = floor(Int, T_max / dt)
    record_every = max(1, N_steps ÷ N_snapshots)
    actual_shots = min(N_snapshots, N_steps ÷ record_every + 1)
    times = [i * record_every * dt for i in 0:(actual_shots-1)]

    println("  T_max = $(round(T_max, digits=3)), dt = $dt")
    println("  N_steps = $N_steps, recording $actual_shots snapshots")
    println("  N_Haar = $N_Haar Haar averages")
    println()

    # Storage for OAT results
    oat_Q_bell = zeros(actual_shots)
    oat_Q_ent = zeros(actual_shots)
    oat_SRE = zeros(actual_shots)
    oat_F_max = zeros(actual_shots)

    # Storage for Haar-averaged results
    haar_Q_bell = zeros(actual_shots)
    haar_Q_ent = zeros(actual_shots)
    haar_SRE = zeros(actual_shots)
    haar_F_max = zeros(actual_shots)
    haar_Q_bell_std = zeros(actual_shots)
    haar_Q_ent_std = zeros(actual_shots)
    haar_SRE_std = zeros(actual_shots)
    haar_F_max_std = zeros(actual_shots)

    # Store snapshots for Haar processing
    snapshots = Vector{Vector{ComplexF64}}(undef, actual_shots)

    # Build gates and initial state
    println("  Building OAT gates...")
    gates = build_oat_gates(N, χ, dt)
    println("  Initializing |+⟩^⊗$N...")
    ψ = make_ket("|+>", N)

    # ==========================================================================
    # PHASE 1: OAT EVOLUTION - Store snapshots
    # ==========================================================================
    println("\n  Phase 1: OAT evolution + metrics")

    # Initial state (t=0)
    snapshots[1] = copy(ψ)
    shot_idx = 2

    # Time evolution
    @showprogress dt=0.5 desc="    OAT evolution: " for step in 1:N_steps
        apply_fast_trotter_step_cpu!(ψ, gates, N)
        normalize_state!(ψ)

        if step % record_every == 0 && shot_idx <= actual_shots
            snapshots[shot_idx] = copy(ψ)
            shot_idx += 1
        end
    end

    # Compute OAT metrics
    @showprogress dt=0.5 desc="    OAT metrics:   " for i in 1:actual_shots
        Q_bell, Q_ent, SRE, F_Q = compute_metrics(snapshots[i], N)
        oat_Q_bell[i] = Q_bell
        oat_Q_ent[i] = Q_ent
        oat_SRE[i] = SRE
        oat_F_max[i] = F_Q
    end

    # ==========================================================================
    # PHASE 2: HAAR AVERAGING
    # ==========================================================================
    println("\n  Phase 2: Haar random averaging (N_Haar = $N_Haar)")

    # Note: Can't use @threads here - SRE uses @threads :static internally
    # SRE will still benefit from multithreading, we just process Haar samples sequentially
    n_threads = Threads.nthreads()
    println("    Using $n_threads threads (SRE internal parallelization)")

    for i in 1:actual_shots
        ψ_base = snapshots[i]

        # Collect Haar samples sequentially (SRE parallelizes internally)
        Q_bell_samples = Float64[]
        Q_ent_samples = Float64[]
        SRE_samples = Float64[]

        for h in 1:N_Haar
            # Apply Haar random unitary
            U = random_unitary(N)
            ψ_haar = U * ψ_base

            # Compute Bell + SRE (skip QFI - it's invariant under unitary)
            Q_bell, Q_ent, _ = get_bell_correlator(ψ_haar; method=OPT_METHOD, max_iter=OPT_ITER)
            SRE = get_stabilizer_renyi_entropy(ψ_haar)

            push!(Q_bell_samples, Q_bell)
            push!(Q_ent_samples, Q_ent)
            push!(SRE_samples, SRE)
        end

        # Store mean and std
        haar_Q_bell[i] = mean(Q_bell_samples)
        haar_Q_ent[i] = mean(Q_ent_samples)
        haar_SRE[i] = mean(SRE_samples)

        # QFI is INVARIANT under unitary - same as OAT
        haar_F_max[i] = oat_F_max[i]

        haar_Q_bell_std[i] = std(Q_bell_samples)
        haar_Q_ent_std[i] = std(Q_ent_samples)
        haar_SRE_std[i] = std(SRE_samples)
        haar_F_max_std[i] = 0.0  # No variance - exactly same as OAT

        # Progress indicator
        if i % 10 == 0 || i == 1 || i == actual_shots
            @printf("    Snapshot %d/%d: Q_bell=%.3f±%.3f, SRE=%.3f±%.3f\n",
                    i, actual_shots, haar_Q_bell[i], haar_Q_bell_std[i],
                    haar_SRE[i], haar_SRE_std[i])
        end
    end

    # ==========================================================================
    # SAVE DATA
    # ==========================================================================
    N_str = @sprintf("%02d", N)
    opt_str = string(OPT_METHOD)

    # OAT data
    oat_file = joinpath(DATA_DIR, "data_OAT_N$(N_str)_$(opt_str).txt")
    open(oat_file, "w") do f
        println(f, "# OAT evolution: N=$N, χ=$χ, dt=$dt, optimizer=$OPT_METHOD")
        println(f, "# t  Q_bell  Q_ent  SRE  F_max")
        for i in 1:actual_shots
            @printf(f, "%.6f  %+.6f  %+.6f  %.6f  %.4f\n",
                    times[i], oat_Q_bell[i], oat_Q_ent[i], oat_SRE[i], oat_F_max[i])
        end
    end
    println("\n  Saved: data/data_OAT_N$(N_str)_$(opt_str).txt")

    # Haar data
    haar_file = joinpath(DATA_DIR, "data_Haar_N$(N_str)_$(opt_str).txt")
    open(haar_file, "w") do f
        println(f, "# OAT + Haar: N=$N, N_Haar=$N_Haar, optimizer=$OPT_METHOD")
        println(f, "# t  Q_bell  Q_bell_std  Q_ent  Q_ent_std  SRE  SRE_std  F_max  F_max_std")
        for i in 1:actual_shots
            @printf(f, "%.6f  %+.6f  %.6f  %+.6f  %.6f  %.6f  %.6f  %.4f  %.4f\n",
                    times[i], haar_Q_bell[i], haar_Q_bell_std[i],
                    haar_Q_ent[i], haar_Q_ent_std[i],
                    haar_SRE[i], haar_SRE_std[i],
                    haar_F_max[i], haar_F_max_std[i])
        end
    end
    println("  Saved: data/data_Haar_N$(N_str)_$(opt_str).txt")

    # ==========================================================================
    # GENERATE PLOTS - 4 columns: QFI | Q_ent | Q_bell | SRE
    # ==========================================================================
    println("\n  Generating plots...")

    # Time in units of π
    times_pi = times ./ π
    xticks_vals = [0, 0.25, 0.5]
    xticks_labels = [L"0", L"\pi/4", L"\pi/2"]

    # Color scheme: OAT = blue, Haar = red
    oat_color = :blue
    haar_color = :red

    # 1. QFI (normalized by N for comparison with SQL=1)
    p_qfi = plot(times_pi, oat_F_max ./ N, lw=2.5, color=oat_color,
                 marker=:circle, ms=3, label="OAT",
                 xlabel=L"\chi t / \pi", ylabel=L"F_\mathrm{max}/N",
                 title=L"QFI", legend=:topright,
                 xticks=(xticks_vals, xticks_labels),
                 ylims=(0, max(maximum(oat_F_max ./ N) * 1.1, N * 1.1)),
                 grid=true, framestyle=:box)
    plot!(p_qfi, times_pi, haar_F_max ./ N, lw=2.5, color=haar_color,
          marker=:square, ms=3, ribbon=haar_F_max_std ./ N, fillalpha=0.2,
          label="Haar")
    hline!(p_qfi, [1.0], ls=:dot, color=:gray, lw=1.5, label="SQL")
    hline!(p_qfi, [N], ls=:dash, color=:gold, lw=1.5, label="HL")

    # 2. Q_ent (entanglement witness)
    p_qent = plot(times_pi, oat_Q_ent, lw=2.5, color=oat_color,
                  marker=:circle, ms=3, label="OAT",
                  xlabel=L"\chi t / \pi", ylabel=L"Q_\mathrm{ent}",
                  title=L"Q_\mathrm{ent}", legend=:topright,
                  xticks=(xticks_vals, xticks_labels),
                  grid=true, framestyle=:box)
    plot!(p_qent, times_pi, haar_Q_ent, lw=2.5, color=haar_color,
          marker=:square, ms=3, ribbon=haar_Q_ent_std, fillalpha=0.2,
          label="Haar")

    # 3. Q_bell (optimized Bell correlator)
    p_qbell = plot(times_pi, oat_Q_bell, lw=2.5, color=oat_color,
                   marker=:circle, ms=3, label="OAT",
                   xlabel=L"\chi t / \pi", ylabel=L"Q_\mathrm{Bell}",
                   title=L"Q_\mathrm{Bell}", legend=:topright,
                   xticks=(xticks_vals, xticks_labels),
                   grid=true, framestyle=:box)
    plot!(p_qbell, times_pi, haar_Q_bell, lw=2.5, color=haar_color,
          marker=:square, ms=3, ribbon=haar_Q_bell_std, fillalpha=0.2,
          label="Haar")

    # 4. SRE (magic)
    p_sre = plot(times_pi, oat_SRE, lw=2.5, color=oat_color,
                 marker=:circle, ms=3, label="OAT",
                 xlabel=L"\chi t / \pi", ylabel=L"M_2(\psi)",
                 title=L"SRE", legend=:topleft,
                 xticks=(xticks_vals, xticks_labels),
                 ylims=(0, Inf), grid=true, framestyle=:box)
    plot!(p_sre, times_pi, haar_SRE, lw=2.5, color=haar_color,
          marker=:square, ms=3, ribbon=haar_SRE_std, fillalpha=0.2,
          label="Haar")

    # Combine into 1x4 grid
    fig = plot(p_qfi, p_qent, p_qbell, p_sre,
               layout=(1, 4), size=(1400, 350),
               margin=5Plots.mm,
               plot_title="OAT vs Haar Scrambling: N=$N (opt=$OPT_METHOD)")

    fig_file = joinpath(FIG_DIR, "fig_OAT_vs_Haar_N$(N_str)_$(opt_str).png")
    savefig(fig, fig_file)
    println("  Saved: figures/fig_OAT_vs_Haar_N$(N_str)_$(opt_str).png")

    # ==========================================================================
    # SUMMARY
    # ==========================================================================
    println("\n" * "="^70)
    println("  RESULTS SUMMARY (N=$N)")
    println("="^70)
    println("  OAT final:  Q_bell=$(round(oat_Q_bell[end], digits=3)), SRE=$(round(oat_SRE[end], digits=3)), F/N=$(round(oat_F_max[end]/N, digits=3))")
    println("  Haar final: Q_bell=$(round(haar_Q_bell[end], digits=3))±$(round(haar_Q_bell_std[end], digits=3)), SRE=$(round(haar_SRE[end], digits=3))±$(round(haar_SRE_std[end], digits=3))")
    println("="^70)

    return (times, oat_Q_bell, oat_SRE, oat_F_max, haar_Q_bell, haar_SRE, haar_F_max)
end

# ==============================================================================
# PART 2: QFI SCALING ANALYSIS FOR HAAR RANDOM STATES
# ==============================================================================
function run_qfi_scaling_analysis()
    println("\n" * "="^70)
    println("  PART 2: QFI SCALING FOR HAAR RANDOM STATES")
    println("="^70)

    N_vals = collect(2:10)
    n_samples = 20  # Haar samples per N

    # Storage
    qfi_mean = Float64[]
    qfi_std = Float64[]

    println("\n  Computing QFI for Haar random states (n_samples=$n_samples)")

    for N in N_vals
        print("    N=$N: ")

        qfi_samples = Float64[]
        dim = 1 << N

        for _ in 1:n_samples
            # Generate Haar random state: U|0⟩
            ψ0 = zeros(ComplexF64, dim)
            ψ0[1] = 1.0  # |00...0⟩
            U = random_unitary(N)
            ψ_haar = U * ψ0

            # Compute QFI using SLD formula (max over x/y/z)
            F_Q = compute_qfi_max(ψ_haar, N)
            push!(qfi_samples, F_Q)
        end

        push!(qfi_mean, mean(qfi_samples))
        push!(qfi_std, std(qfi_samples))
        @printf("QFI = %.2f ± %.2f (QFI/N = %.2f, QFI/N² = %.3f)\n",
                qfi_mean[end], qfi_std[end],
                qfi_mean[end]/N, qfi_mean[end]/N^2)
    end

    # Save data
    scaling_file = joinpath(DATA_DIR, "qfi_scaling_haar.txt")
    open(scaling_file, "w") do f
        println(f, "# QFI scaling for Haar random states")
        println(f, "# N  QFI_mean  QFI_std  QFI/N  QFI/N^2")
        for (i, N) in enumerate(N_vals)
            @printf(f, "%d  %.6f  %.6f  %.4f  %.6f\n",
                    N, qfi_mean[i], qfi_std[i],
                    qfi_mean[i]/N, qfi_mean[i]/N^2)
        end
    end
    println("\n  Saved: data/qfi_scaling_haar.txt")

    # Plot: QFI vs N with SQL and HL reference lines
    p = plot(N_vals, qfi_mean, lw=3, color=:red, marker=:circle, ms=8,
             ribbon=qfi_std, fillalpha=0.3,
             label="Haar random", xlabel=L"N", ylabel=L"F_Q",
             title="QFI Scaling: Haar Random States",
             legend=:topleft, grid=true, framestyle=:box,
             yscale=:log10, xscale=:log10)

    # Reference lines
    N_ref = collect(2:10)
    plot!(p, N_ref, N_ref, lw=2, ls=:dash, color=:blue, label="SQL (N)")
    plot!(p, N_ref, N_ref.^2, lw=2, ls=:dot, color=:gold, label="HL (N²)")

    fig_file = joinpath(FIG_DIR, "fig_qfi_scaling_haar.png")
    savefig(p, fig_file)
    println("  Saved: figures/fig_qfi_scaling_haar.png")

    # Also plot QFI/N to see the constant
    p2 = plot(N_vals, qfi_mean ./ N_vals, lw=3, color=:red, marker=:circle, ms=8,
              ribbon=qfi_std ./ N_vals, fillalpha=0.3,
              label="Haar random", xlabel=L"N", ylabel=L"F_Q / N",
              title="QFI/N Scaling: Haar Random States",
              legend=:topright, grid=true, framestyle=:box)
    hline!(p2, [1.0], lw=2, ls=:dash, color=:blue, label="SQL (F=N)")

    fig_file2 = joinpath(FIG_DIR, "fig_qfi_per_N_haar.png")
    savefig(p2, fig_file2)
    println("  Saved: figures/fig_qfi_per_N_haar.png")

    println("\n  Result: Haar random states show QFI ~ N (SQL scaling)")
end

# ==============================================================================
# MAIN
# ==============================================================================
if abspath(PROGRAM_FILE) == @__FILE__
    println("="^70)
    println("  OAT + HAAR RANDOM UNITARY COMPARISON")
    println("="^70)
    println("  N values: $N_range")
    println("  N_snapshots: $N_snapshots")
    println("  N_Haar: $N_Haar")
    println("  Output: $OUTPUT_DIR")
    println()

    # =========================================================================
    # PART 1: OAT vs Haar comparison (existing)
    # =========================================================================
    for N in N_range
        # First compare optimizers to find the best one
        best_opt = compare_optimizers(N)

        # Then run full simulation
        run_simulation(N)
    end

    # =========================================================================
    # PART 2: QFI SCALING FOR HAAR RANDOM STATES
    # =========================================================================
    run_qfi_scaling_analysis()

    println("\n" * "="^70)
    println("  ALL SIMULATIONS COMPLETE!")
    println("  Data: $DATA_DIR")
    println("  Figures: $FIG_DIR")
    println("="^70)
end
